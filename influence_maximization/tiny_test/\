#!/usr/bin/python

import numpy as np
import cplex
from cplex.exceptions import CplexError
import sys


# parameters
# constants
T   = 10      # time horizon
S   = 1       # |seed set|
M   = 100     # big M
UB  = 100     # upper bound of variables
# network parameters - set_network()
N           = 0      # number of nodes in network
w_to        = []
w_fr        = []
w_val       = []
# objective and constraint bounds - set_coefficients()
im_obj_t    = []
im_obj_0    = [] 
im_ub       = []
im_rhs      = []
im_sense    = []
# sparse constraint coefficient matrix
ind0        = []
ind1        = []
val         = []


def set_network():
    global N
    N       = 60      # number of nodes in network
    w_to    = range(1, N)
    w_fr    = range(0, N-1)
    w_val   = [-0.8] * (N-1)


def set_coefficients():
    im_obj_t.extend([1] * (N*T))
    im_obj_0    = [1] * N
    im_ub       = [UB] * (N*T)
    im_rhs      = [0]*(N*T) + [M]*(N*T) + [S]
    im_sense    = 'L' * (2*N*T+1)
    print len(im_obj_0), len(im_obj_t), len(im_ub)
    print len(im_sense), len(im_rhs)


def set_constraint_matrix():
    # sparse constraint matrix
    # basic indices and values
    ind_w   = (w_to, w_fr)
    val_w   = w_val
    ind_I   = (range(N), range(N))
    val_I   = [1] * N
    val_M   = [M] * N
    for t in xrange(T):
        # nonzero coefficients of w
        ind0.extend([x+t*N for x in ind_w[0]])
        ind1.extend([x+t*N for x in ind_w[1]])
        val.extend(val_w)
        # nonzero coefficients of I in c2
        ind0.extend([x+t*N for x in ind_I[0]])
        ind1.extend([x+(t+1)*N for x in ind_I[1]])
        val.extend(val_I)
        # nonzero coefficients of MI
        ind0.extend([x+(t+T)*N for x in ind_I[0]])
        ind1.extend(ind_I[1])
        val.extend(val_M)
        # nonzero coefficients of I in c3
        ind0.extend([x+(t+T)*N for x in ind_I[0]])
        ind1.extend([x+(t+1)*N for x in ind_I[1]])
        val.extend(val_I)
    ind0.extend([2*N*T] * N)
    ind1.extend(range(N))
    val.extend([1] * N)
    print len(ind0), len(ind1), len(val)


def populatebynonzero(prob):
    print len(im_obj_0), len(im_obj_t), len(im_ub)
    print len(im_sense), len(im_rhs)
    prob.objective.set_sense(prob.objective.sense.maximize)
    # lower bounds are all 0.0 (the default)
    # xi0 is binary
    # xit is continuous for t >= 1
    prob.variables.add(obj = im_obj_0, types = prob.variables.type.binary * N)
    prob.variables.add(obj = im_obj_t, ub = im_ub)
    prob.linear_constraints.add(senses = im_sense, rhs = im_rhs)    
    prob.linear_constraints.set_coefficients(zip(ind0, ind1, val))


def optimize():
    set_network()
    set_coefficients()
    set_constraint_matrix()
    try:
        im_prob = cplex.Cplex()
        handle = populatebynonzero(im_prob)
        im_prob.solve()
    except CplexError, exc:
        print exc
        return
    print
    # solution.get_status() returns an integer code
    print "Solution status = " , im_prob.solution.get_status(), ":",
    # the following line prints the corresponding string
    print im_prob.solution.status[im_prob.solution.get_status()]
    print "Solution value  = ", im_prob.solution.get_objective_value()
    x     = im_prob.solution.get_values()
    x     = np.reshape(x, (T+1, N))
    print "Solution variables = ", x


if __name__ == "__main__":
    optimize()

